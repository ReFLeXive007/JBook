# Изоляция транзакций в реляционных БД

## Условие

Что такое транзакция?

Расскажите на примере транзакционной БД какие существуют уровни изоляции транзакций.

Для примера можно взять PostgreSQL.

## Решение

Грубо говоря, транзакция — это набор действий (в этот набор может входить как одна операция, так и несколько), которые либо буду выполнены все и полностью, либо не выполнены вовсе и тогда транзакция не должна произвести никакого эффекта.

Т.е. транзакиця объединяет последовательность действий в одну операцию 'всё или ничего'.

При этом важно, чтобы транзакционная система удовлетворяла следующим свойствам:

* Atomicity — атомарность, гарантирует, что все операции транзакции выполнятся либо полностью, либо не выполнятся вовсе (в случае ошибки — откат произойдет rollback)
* Consistency — согласованность, гарантирует, что данные останутся согласованными после выполнения транзакции
* Isolation — изолированность, обеспечивает независимость транзакций друг от друга
* Durability — устойчивость, гарантирует, что зафиксированные изменения сохранятся даже в случае сбоя системы

Поэтому, если дать определение транзакции для транзакционной БД, например PostgreSQL, то можно сказать, что транзакцией называется множество операций, которое переводит базу данных из одного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция).

При выполнении нескольких транзакций возникают следующие вопросы:

* Какой будет результат, если одновременно выполняется несколько транзакций?

* Какие изменения видит одна транзакция относительно другой параллельно выполняемой транзакции?

Ответы на эти вопросы зависят от уровня изолированности транзакицй.

В стандарте SQL описывается четыре уровня изоляции транзакции, в порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:

* READ_UNCOMMITTED
* READ_COMMITTED
* REPEATABLE_READ
* SERIALIZABLE

Эти уровни определяются перечислением аномалий, которые допускаются или не допускаются при одновременном выполнении транзакций.

### Аномалии

### Грязное чтение (dirty read)

Грязное чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не откатится.

Такая аномалия возникает, когда транзакция читает еще не зафиксированные (не закомиченные) изменения, сделанные другой транзакцией.

Например, первая транзакция переводит все деньги со счета клиента на другой счет, но не фиксирует изменение. Другая транзакция читает состояние счета, получает 0 и отказывает клиенту в выдаче наличных — несмотря на то, что первая транзакция прерывается и откатывает свои изменения, так что значения 0 никогда не существовало в базе данных.

### Неповторяющееся чтение (non-repeatable read)

Неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;

Т.е. транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения). Тогда первая транзакция получит разные результаты.

Например, пусть одна транзакция уменьшает сумму на счете на 100. Она проверяет текущее значение, получает 1000 и решает, что уменьшение возможно. В это время вторая транзакция уменьшает сумму на счете до нуля и фиксирует изменения. Если бы теперь первая транзакция повторно проверила сумму, она получила бы 0 (но она уже приняла решение уменьшить значение, и счет 'уходит в минус').

### Фантомное чтение (phantom reads)

Фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.

Например, пусть клиенту нельзя иметь более 3 счетов. Первая транзакция собирается открыть новый счет, проверяет их текущее количество (скажем, 2) и решает, что открытие возможно. В это время вторая транзакция также пытается открыть клиенту новый счет и фиксирует изменения. Если бы теперь первая транзакция перепроверила количество, она получила бы 3 (но она уже выполняет открытие еще одного счета и у клиента их оказывается 4).

### Уровни изоляции транзакций

#### READ_UNCOMMITTED

На этом уровне изолированности видны все изменения параллельных транзакций, даже незакомиченных.

Возможно чтение неподтверждённых данных (грязное чтение или dirty read) — это чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок.

Несмотря на то, что этот уровень изоляции наиболее производительный, он редко используется, так как к этому уровню изоляции применимы все виды аномалий, перечисленных выше.

В PostgreSQL этот уровень изоляции по сути не поддерживается. Формально, конечно, в PostgreSQL можно указать уровень Read Uncommitted, но работать она будет точно так же, как Read Committed.

#### READ_COMMITTED

Чтение подтверждённых данных (read committed) — это чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций.

В транзакции, работающей на этом уровне, запрос SELECT (без предложения FOR UPDATE/SHARE) по сути видит снимок базы данных в момент начала выполнения запроса. При этом он может видеть результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы.

Также заметьте, что два последовательных оператора SELECT могут видеть разные данные даже в рамках одной транзакции, например, в ситуации, если какие-то другие транзакции коммитят изменения после выполнения первого вызова SELECT.

Этот уровень изоляции стоит в PostgreSQL по умолчанию.

Применимые аномалии: Неповторяющееся чтение (non-repeatable read) и Фантомное чтение (phantom reads).

#### REPEATABLE_READ

Этот уровень фиксирует (по сути блокирует изменяемые строки) состояние базы на момент начала транзакции. Все запросы в её рамках работают с этим снимком данных, исключая неповторяющееся чтение. Однако возможно фантомное чтение (phantom read).

Разница между фантомным и неповторяющимся чтением:

* Неповторяющееся чтение: одни и те же строки изменяются между запросами.
* Фантомное чтение: изменяется набор строк, участвующих в запросе.

#### SERIALIZABLE

Этот уровень обеспечивает максимальную изоляцию: транзакции выполняются последовательно, а не параллельно. Изменения в одной транзакции становятся видимыми только после её завершения.

Исключает аномалии конкурентного доступа, однако является наиболее низко производительным уровнем, а потому применяется редко.

### Итоговая таблица

|                  | Грязное чтение          | Неповторяемое чтение    | Фантомное чтение        |
| ---------------- | ----------------------- | ----------------------- | ----------------------- |
| Read Uncommitted | Допускается, но не в PG | Возможно                | Возможно                |
| Read Committed   | Невозможно              | Возможно                | Возможно                |
| Repeatable Read  | Невозможно              | Невозможно              | Возможно                |
| Serializable     | Невозможно              | Невозможно              | Невозможно              |

## Полезные ссылки

1. [Уровни изоляции транзакций с примерами на PostgreSQL](https://habr.com/ru/articles/317884/)
2. [Postgres PRO#13.2. Изоляция транзакций](https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso)
3. [Postgres PRO#3.4. Транзакции](https://postgrespro.ru/docs/postgrespro/10/tutorial-transactions)
4. [MVCC-1. Изоляция](https://habr.com/ru/companies/postgrespro/articles/442804/)
5. [Уровни изоляции транзакций в PostgreSQL, MySQL, MSQL, Oracle с примерами на Go](https://habr.com/ru/articles/857486/)
