# CAP теорема

## Введение

Идеальной архитектуры не существует. Каждое решение подразумевает определенные компромиссы между чтением, записью и потреблением памяти.
Также есть и другие важные факторы для систем - это согласованность данных и доступность.

Чтобы понимать как эти факторы влияют на проектирование ваших систем надо понимать CAP-теорему.

Первое упоминание теоремы датируется осенью 1998 года Эриком Брюэром. Затем, она была опубликована как "CAP принцип" в 1999 и представлена как гипотеза на симпозиуме принципов распределенных вычислений в 2000 году. В 2002 году Сэт Гилберт и Нэнси Линч опубликовали формальное доказательство гипотезы Брюэра, после чего она стала теоремой.

## CAP

CAP-теорема утверждает, что любая распределенная система может гарантированно предоставить только два из трех свойств:

* Consistency (консистентность или согласованность)

    Означает, что все клиенты одновременно видят одни и те же данные, к какому бы узлу они ни подключились

* Availability (доступность)

    Означает, что любой клиент, запрашивающий­ данные, получает ответ, даже если некоторые из узлов недоступны

* Partitioning tolerance (отказоустойчивость)

    Система продолжает функционировать каким-либо образом даже при разрывах сети между узлами

Согласно теореме CAP, одним из этих свойств необходимо пожертвовать, чтобы обеспечить поддержку двух других.

Представим следующую ситуацию: пусть у нас есть 3 сервера и один из них отказал (например, из-за разрыва сети).

![Server failed](../../images/patterns/architecture/cap/server_failed.png)

В таком случае server 3 уже не может взаимодействовать с остальными.

Данные, которые клиенты записывают в server 1 или server 2, уже не могут дойти до server 3.

Если же кто-то запишет данные в server 3 и они не успеют дойти до server 1 и 2, это будет означать, что содержимое серверов неактуально.

Если мы предпочтем согласованность вместо доступности (CP) нам придется заблокировать все операции записи на узлах server 1 и server 2, чтобы избежать рассинхронизации данных между этими тремя серверами. Например, возвращать ошибки и отменять операции записи, пока проблема не будет решена. Т.е. система станет недоступной.

Если же мы отдадим предпочтение доступности перед согласованностью (AP), то система продолжит принимать операции чтения, несмотря на то что она может вернуть устаревшие данные (пользователь может получить разные данные на один и тот же запрос, потому что попадет в разные узлы).

Операции записи, также останутся доступными, но только на узлах server 1 и 2, а после устранения сетевых неполадок данные будут синхронизированы с server 3.

## Модели согласованности

Модель согласованности определяет степень согласованности данных.

Выделяют следующие разновидности:

* Строгая согласованность

    Любая операция чтения возвращает значение, соответствующее результату самой последней операции записи. Клиент всегда получает актуальные данные.

* Слабая согласованность

    Последующие операции чтения не всегда могут возвращать самое последнее значение.

* Согласованность в конечном счете.

    Это разновидность слабой согласованности. Рано или поздно все обновления распространяются по системе и все реплики становятся согласованными.

Жесткая согласованность обычно достигается за счет того, что операции чтения/записи считаются успешными только после подтверждения записи всеми репликами. Это не самый оптимальный подход для высокодоступных систем, так как он может блокировать новые операции.

Зачастую реальной консистентностью распределенная система похвастаться не может. Обычно речь идет о sequential consistency - в каждом узле соблюдается указанный порядок операций (например, сначала производится запись, а потом чтение), при этом итоговый порядок операций между всеми узлами может быть недетерминирован.

![](../../images/patterns/architecture/cap/sequential_consistency.png)

Также, возможна ситуация, когда для пользователя достаточно гарантировать, что он всегда будет читать свои записи. В таком случае, нужно просто всегда направлять одного пользователя на один и тот же узел.

## Подводные камни

Важно подметить, что данная теорема относится к случаю, в котором присутствует разбиение системы на узлы, реплики. Из-за этого, в 2010 году появилась PACELC теорема, которая гласит: если существует разделение сети (т.е. P), то существует компромисс между консистентностью и доступностью; иначе, компромисс лежит между задержкой и консистентностью.

Т.е. 

## Полезные ссылки

1. [Wikipedia CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem)
2. [Wikipedia Sequential consistency](https://en.wikipedia.org/wiki/Sequential_consistency)
3. [Ты используешь CAP-теорему НЕПРАВИЛЬНО! System design интервью](https://www.youtube.com/watch?v=bQMW5yijyAo)
4. [CAP Theorem in System Design Interviews](https://www.youtube.com/watch?v=VdrEq0cODu4)


Давайте обсудим все 3 слова CAP:

Согласованность: каждый запрос на чтение возвращает один и тот же результат независимо от того, с какого узла мы считываем данные. Это означает, что все узлы одновременно имеют одни и те же данные. На приведенном выше рисунке вы можете видеть, что наш кластер баз данных согласован, поскольку все узлы имеют одни и те же данные.

Доступность: система доступна и всегда может отвечать на запросы, даже если некоторые узлы выйдут из строя. Это означает, что даже если некоторые узлы выйдут из строя, система должна продолжать обслуживать запросы с помощью других работоспособных узлов.

Устойчивость к разделению: система продолжает работать даже в случае сбоя связи или разделения сети между различными узлами.

Пример: Пусть имеется 3 узла A, B, C.

Согласованность: все A, B и C имеют одинаковые данные. Если в узле B происходит обновление, то происходит репликация данных, и B распространит это обновление на A и C.

Доступность: Представим, что узел B столкнулся с аппаратным сбоем. Узлы A и C все еще работают. Несмотря на сбой узла B, система в целом остается доступной, поскольку узлы A и C все еще могут отвечать на запросы клиентов.

Допуск к разделению: происходит сетевое разделение, которое отделяет B от A и C. Узел B все еще может функционировать и обслуживать запросы, но он не может взаимодействовать с A и C.

Что такое теорема CAP
Теорема CAP гласит, что в распределённой системе можно одновременно гарантировать только два из этих трёх свойств. Все три свойства одновременно обеспечить невозможно.

CA — возможно

AP — возможно

CP — возможно

CAP — невозможно

Это вполне логично, если вдуматься.

В распределённой системе неизбежно возникают сбои в работе сети, поэтому система должна быть устойчива к таким сбоям. Это означает, что в распределённой системе «P» всегда будет присутствовать. Мы будем искать компромисс между CP и AP.

Почему мы можем достичь только CP или AP, а не CAP?
Снова рассмотрим тот же пример с узлами A, B и C.

Предположим, что происходит разделение сети, и B теряет связь с A и C.

Тогда B не сможет передать свои изменения A и C.

Если мы поставим доступность на первое место, то продолжим обслуживать запросы. B не сможет передать свои изменения A и C. Таким образом, пользователи, которым отвечает B, могут получить другие результаты, чем те, которым отвечают A и C. Следовательно, мы добились доступности, пожертвовав согласованностью.

Если мы поставим во главу угла согласованность, то не будем принимать запросы до тех пор, пока не будет устранена проблема с разделением сети B, потому что мы не хотим, чтобы операция записи в B не доходила до узлов A и C. Мы хотим, чтобы в A, B и C были одни и те же данные. Поэтому мы добились согласованности, пожертвовав доступностью.

Почему бы не выбрать CA?
CA означает, что сетевого разделения не происходит, вы можете добиться как согласованности, так и доступности, поскольку связь не является проблемой.

На практике сетевое разделение обязательно произойдет в распределенной системе. Итак, мы выбираем между CP или AP.

Что выбрать, CP или AP?
Для безопасных приложений, таких как банковское дело, платежи, акции и т.д., соблюдайте согласованность. Вы не можете позволить себе показывать противоречивые данные.

Для социальных сетей и т.д. соблюдайте доступность. Если количество лайков к посту не совпадает у разных пользователей, мы в порядке.